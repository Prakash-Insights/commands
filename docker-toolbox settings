For docker-desktop-toolbox

First step is kubectl.exe minikube.exe these files paste into Docker-Toolbox directory
kubectl.exe minikube.exe and helm.exe download from official source

copy-paste in c drive
create env variable in PATH(SYStem)

in D-Toolbox, IP is working instead of localhost/127.0.0.1
docker IP 192.168.99.100
kubectl cluster-info    //get IP info and it IP expose to run locally (IP:Kubernetes master) (https://192.168.99.101:<PORT>)

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<command>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
minikube start // starting minikube cluster
minikube status
minikube dashboard



Docker-------------------
docker build .    // build image from Dockerfile
docker build -t webapp1 .     // with tag name
docker run -d -p 8080:80 --name mywebapp1 webapp1    // run and test
docker inspect -f "{{ .NetworkSettings.Networks.nat.IPAddress }}" mywebapp1
Docker-Compose-------------------
docker-compose build
docker-compose logs CONTAINER_NAME
docker-compose up
docker-compose down

docker login
docker tag d2a92e4c3a03 insights/receiver_data:latest
docker push insights/receiver_data

docker save receiver_data > receiver_data.tar
docker load --input receiver_data.tar


kubectl cluster-info
helm version --short
kubectl version --short
kubectl config get-contexts
kubectl get pods --namespace kube-system
kubectl get namespace
kubectl describe svc frontend  or  minikube service frontend

example
kubectl apply -f https://k8s.io/examples/pods/two-container-pod.yaml     //apply = create and build
kubectl get pod two-containers --output=yaml
kubectl exec -it two-containers -c nginx-container -- /bin/bash
kubectl exec -it two-containers -c nginx-container ps aux
kubectl exec -it two-containers -c nginx-container apt-get update
kubectl exec -it two-containers -c nginx-container apt-get install curl
kubectl exec -it two-containers -c nginx-container curl localhost


kubectl get pods --show-all -w
kubectl logs mc2 -c producer    //mc2=podName , producer=container(1st) , -c=container
kubectl get pod NAME -o wide

helm list
helm install 
helm search hub HUBNM
helm search repo REPONM
helm show values NM
helm lint HELMNM

kompose up -f website-sample.yml
kompose convert -f website-sample.yml
kompose down  -f website-sample.yml

# kubectl create namespace nsb-rabbit
# helm install my-rabbit stable/rabbitmq-ha --namespace nsb-rabbit -f rabbit-values.yaml
# kubectl get deployments,pods,services --namespace nsb-rabbit
# kubectl describe all --namespace=nsb-rabbit
# NOT--> kubectl patch service my-rabbit-rabbitmq-ha --namespace=nsb-rabbit --type='json' --patch='[{"op": "replace", "path": "/spec/ports/0/nodePort", "value":31000}]'
# helm repo list
# %TEMP%\helm     //  tgz>open with 7z
# kubectl exec my-rabbit-rabbitmq-ha-0  --namespace=nsb-rabbit -- rabbitmqctl list_queues
# kubectl exec my-rabbit-rabbitmq-ha-0  --namespace=nsb-rabbit -- rabbitmqctl list_users
# kubectl exec my-rabbit-rabbitmq-ha-0  --namespace=nsb-rabbit -- rabbitmqctl status
# kubectl exec my-rabbit-rabbitmq-ha-0  --namespace=nsb-rabbit -- rabbitmqctl --help
# kubectl exec my-rabbit-rabbitmq-ha-0  --namespace=nsb-rabbit -- ifconfig -a
# NOT--> curl -sS -f --user guest:guest 127.0.0.1:15672/api/healthchecks/node{"status":"ok"}
# kubectl get all -o wide --namespace nsb-rabbit
# kubectl describe svc my-rabbit-rabbitmq-ha  --namespace=nsb-rabbit
# kubectl cluster-info    //get IP info and it IP expose to run locally (https://192.168.99.101:<PORT>)
		<1> Kubernetes master is running at https://192.168.99.101:8443
		<2> KubeDNS is running at https://192.168.99.101:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy
		<3> service/my-rabbit-rabbitmq-ha  NodePort    10.96.34.149  15672:31673/TCP,5672:32584/TCP,4369:31056/TCP 
			<3.1>  (https://192.168.99.101:31673)
		<4> service/my-rabbit-rabbitmq-ha-discovery   ClusterIP   None           <none>        15672/TCP,5672/TCP,4369/TCP
# kubectl exec -it my-rabbit-rabbitmq-ha-0  --namespace=nsb-rabbit hostname            // container hostname
# kubectl exec -it my-rabbit-rabbitmq-ha-0  --namespace=nsb-rabbit -- uname -r           // container linux version
# kubectl exec -it my-rabbit-rabbitmq-ha-0  --namespace=nsb-rabbit -- cat /proc/version  // container linux version
# NOT--> kubectl exec -it my-rabbit-rabbitmq-ha-0  --namespace=nsb-rabbit -- cat /etc/*{release,version}



@ helm fetch --untar stable/rabbitmq-ha
@ helm install . --name rmq-old --namespace rmq-old
@ https://hub.helm.sh/

$ doskey /LISTSIZE=1000
$ doskey /HISTORY > E:\experi-Lab\cmd-26-jan.txt

docker-machine env
minikube docker-env
bash > eval $(minikube docker-env)
minikube ssh
	$ docker images

----------------------help-----------------------
 pod (po), service (svc), replicationcontroller (rc), deployment (deploy), replicaset (rs)

Examples:
  # Create a service for a replicated nginx, which serves on port 80 and connects to the containers on port 8000.
  kubectl expose rc nginx --port=80 --target-port=8000

  # Create a service for a replication controller identified by type and name specified in "nginx-controller.yaml",
which serves on port 80 and connects to the containers on port 8000.
  kubectl expose -f nginx-controller.yaml --port=80 --target-port=8000

  # Create a service for a pod valid-pod, which serves on port 444 with the name "frontend"
  kubectl expose pod valid-pod --port=444 --name=frontend

  # Create a second service based on the above service, exposing the container port 8443 as port 443 with the name
"nginx-https"
  kubectl expose service nginx --port=443 --target-port=8443 --name=nginx-https

  # Create a service for a replicated streaming application on port 4100 balancing UDP traffic and named 'video-stream'.
  kubectl expose rc streamer --port=4100 --protocol=UDP --name=video-stream

  # Create a service for a replicated nginx using replica set, which serves on port 80 and connects to the containers on
port 8000.
  kubectl expose rs nginx --port=80 --target-port=8000

  # Create a service for an nginx deployment, which serves on port 80 and connects to the containers on port 8000.
  kubectl expose deployment nginx --port=80 --target-port=8000

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<command>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>




----------------------------------------URL-----------------------------------------
https://channel9.msdn.com/Series/Docker-for-NET-Developers/Multi-container-ASPNET-5-apps-with-Nginx-and-Redis
https://www.mirantis.com/blog/multi-container-pods-and-container-communication-in-kubernetes/
https://www.ibm.com/cloud/garage/content/course/helm-fundamentals/helm-def
https://docs.min.io/docs/distributed-minio-quickstart-guide.html
https://docs.bitnami.com/kubernetes/how-to/deploy-application-kubernetes-helm/
https://github.com/bitnami/charts/tree/master/bitnami

25Jan
https://codeburst.io/using-rabbitmq-for-microservices-communication-on-docker-a43840401819
https://www.codeproject.com/Articles/1267590/Developing-Microservices-with-NET-Core-2-1-RabbitM
https://www.katacoda.com/javajon/courses/kubernetes-applications/rabbitmq
https://www.stevejgordon.co.uk/asp-net-core-2-ihostedservice
GD-->  https://docs.particular.net/samples/hosting/docker/
GD--> https://docs.particular.net/nservicebus/dotnet-templates#nservicebus-docker-container

Check:
https://www.ben-morris.com/using-docker-to-build-and-deploy-net-core-console-applications/
https://itnext.io/overview-of-nats-streaming-ea0e80449507

https://docs.nats.io/
https://github.com/nats-io/nats.net
http://nats-io.github.io/nats.net/

Google :
dot net console application deploy in docker container

-----------------------------------------------------------------File--------------------------------------------

--------------three-pods.yaml---------------

apiVersion: v1
kind: Pod
metadata:
  name: three-containers
spec:
  restartPolicy: Never
  containers:

  - name: sender-container
    image: insights/sender

  - name: receiver-container
---------------------------------Example-2--------------
version: '2.1'
services:
 rabbitmq:
    container_name: "4340_rabbitmq"
    tty: true
    image: rabbitmq:management
    ports:
      - 15672:15672
      - 15671:15671
      - 5672:5672
    volumes:
      - ./rabbitmq/lib:/var/lib/rabbitmq
 new_user_notification:
    container_name: "app_new_user_notification"
    build:
      context: .
      dockerfile: Dockerfile
    env_file:
      - ./un.env
    links:
      - rabbitmq
    depends_on:
      - rabbitmq
    command: ["./wait-for-it.sh", "rabbitmq:5672", "-t", "120", "--", "node", "newusernotification.js"]
--------------------------------------------------


    


